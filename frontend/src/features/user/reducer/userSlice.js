import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { userAPI } from 'features/user';


// const initialState = {
//   value: 0,
//   status: 'idle',
// };

// // The function below is called a thunk and allows us to perform async logic. It
// // can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// // will call the thunk with the `dispatch` function as the first argument. Async
// // code can then be executed and other actions can be dispatched. Thunks are
// // typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//   'counter/fetchCount',
//   async (amount) => {
//     const response = await fetchCount(amount);
//     // The value we return becomes the `fulfilled` action payload
//     return response.data;
//   }
// );

// export const userSlice = createSlice({
//   name: 'counter',
//   initialState,
//   // The `reducers` field lets us define reducers and generate associated actions
//   reducers: {
//     increment: (state) => {
//       // Redux Toolkit allows us to write "mutating" logic in reducers. It
//       // doesn't actually mutate the state because it uses the Immer library,
//       // which detects changes to a "draft state" and produces a brand new
//       // immutable state based off those changes
//       state.value += 1;
//     },
//     decrement: (state) => {
//       state.value -= 1;
//     },
//     // Use the PayloadAction type to declare the contents of `action.payload`
//     incrementByAmount: (state, action) => {
//       state.value += action.payload;
//     },
//   },
//   // The `extraReducers` field lets the slice handle actions defined elsewhere,
//   // including actions generated by createAsyncThunk or in other slices.
//   extraReducers: (builder) => {
//     builder
//       .addCase(incrementAsync.pending, (state) => {
//         state.status = 'loading';
//       })
//       .addCase(incrementAsync.fulfilled, (state, action) => {
//         state.status = 'idle';
//         state.value += action.payload;
//       });
//   },
// });

// export const { increment, decrement, incrementByAmount } = userSlice.actions;

// // The function below is called a selector and allows us to select a value from
// // the state. Selectors can also be defined inline where they're used instead of
// // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// export const selectCount = (state) => state.user.value;

// // We can also write thunks by hand, which may contain both sync and async logic.
// // Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd = (amount) => (dispatch, getState) => {
//   const currentValue = selectCount(getState());
//   if (currentValue % 2 === 1) {
//     dispatch(incrementByAmount(amount));
//   }
// };





const userJoinPage = async (X) => {
  const res = await userAPI.userJoin(X)  // async : 비동기(호출 되었을 때? = 값이 들어 올때 까지) / await : 이 함수가 호출 되었을 때 까지 기다려 => 값이 들어오면 반응 할거야
  return res.data
}

const userDetailPage = async (X) => {
  const res = await userAPI.userDetail(X)
  return res.data
}

const userListPage = async () => {
  const res = await userAPI.userList()  // async : 비동기(호출 되었을 때? = 값이 들어 올때 까지) -> 값이 들어오면 반응 BUT list는 'useEffect' 사용하기에 즉시 이벤트 발생
                                             // await : 이 함수가 호출 되었을 때 까지 기다려 BUT list는 필요 값 없으므로 바로 반응
                                             // if 필요 값 지정 시, JAVA에서 값 송출하는 것이 없기에, 계속 wait 중 -> (반응 없음)값 확인 불가
  return res.data
}

const userLoginPage = async (X) => {
  const res = await userAPI.userLogin(X)
  return res.data
}

const userModifyPage = async (X) => {
  const res = await userAPI.userModify(X)
  return res.data
}

const userRemovePage = async (X) => {
  const res = await userAPI.userRemove(X)
  return res.data
}

export const joinPage = createAsyncThunk('users/join', userJoinPage)
export const detailPage = createAsyncThunk('users/dtail', userDetailPage)
export const listPage = createAsyncThunk('users/list', userListPage)
export const loginPage = createAsyncThunk('users/login', userLoginPage)
export const modifyPage = createAsyncThunk('users/modify', userModifyPage)
export const removePage = createAsyncThunk('users/remove', userRemovePage)
export const logout = () => {
  window.localStorage.setItem('sessionUser','')
  window.location.href = '/home'
}
const changeNull = ls =>{
  for(const i of ls ){
    document.getElementById(i).value = ''
  }
}

// 예시 자료
// (alias) createSlice<{
//   userState: {};
//   type: string;
//   keyword: string;
//   params: {};
// }, {}, any>(options: CreateSliceOptions<{
//   userState: {};
//   type: string;
//   keyword: string;
//   params: {};
// }, {}, any>): Slice<...>
// import createSlice

const userSlice = createSlice({
  name: 'users',
  initialState: {
    userState: {
      // userId : '', 
      username:'', password:'', email:'', name:'', regDate: ''
    },
    type: '',
    keyword: '',
    params: {}
  },
  reducers: {},
  extraReducers: {
    [joinPage.fulfilled]: ( state, action ) => { 
      state.userState = action.payload 
      window.location.href = `/users/login`
    },
    [detailPage.fulfilled]: ( state, {meta, payload} ) => { state.userState = payload},
    [listPage.fulfilled]: ( state, {meta, payload} ) => { state.pageResult = payload },
    [loginPage.fulfilled]: ( state, {meta, payload} ) => {
      state.userState = payload
      window.localStorage.setItem('sessionUser', JSON.stringify(payload))
      if(payload.username != null){
        alert(`${payload.name}님 환영합니다`)
        window.location.href = `/users/detail`
      }else{
        alert('아이디, 비번 오류로 로그인 실패  ')
        changeNull(['username','password'])
      }
    },
    [modifyPage.fulfilled]: ( state, action ) => { 
      state.userState = action.payload 
      window.localStorage.setItem('sessionUser', JSON.stringify(action.payload))
    },
    [removePage.fulfilled]: ( state, {meta, payload }) => { 
      state.userState = payload
      window.localStorage.setItem('sessionUser', '')
    }
  }
})

export const currentUserState = state => state.users.userState
export const currentUserParam = state => state.users.param

export default userSlice.reducer;